# 背景
在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号 PID，退出状态 the termination status of the process，运行时间 the amount of CPU time taken by the process 等)。直到父进程通过 wait / waitpid 来取时才释放。

进程从退出开始，到它的退出状态信息被父进程的 wait/waitpid 读走，在这个阶段中，进程将仍然存在于内核进程表中，这个阶段的进程的状态是终止态或称为僵尸态。而僵尸态进程称为僵尸进程，而父进程读子进程退出状态信息的动作则称为”reap”(这是一个术语，含义是收割、收走)，即为子进程收尸。

![](attachments/Pasted%20image%2020230705172139.png)

# 定义
inux僵尸进程是一个已经终止但是其父进程没有调用wait 对其进行善后处理获取终止进程的有关信息的进程；
僵尸进程是当子进程比父进程先结束，而父进程尚未调用 wait() 或 waitpid() 对它进行清理，这时的进程状态称为僵死状态，处于僵死状态的进程称为僵尸进程(zombie process)。
注：如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源。

# 影响
实际上僵尸进程的影响并不大。
- CPU资源
首先，它不占用任何 CPU 资源，因为它已经执行完成了，操作系统将不会调度到它 (因为不在就绪队列中)。

- 内存资源
其次，它占用的内存资源也非常少，仅占用一个进程表项的内存而已。

- FD资源
对于其它资源的占用 (例如打开的文件描述符)，也都基本完全释放了。

- 其他影响
如果父进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

- 小结：
所以，僵尸进程就算过多，也不会降低操作系统的性能。
僵尸进程最大的影响是，当僵尸进程太多时，可能会占满 Linux 的进程表空间，使得无法再创建新进程，因为每个用户能够创建的进程数是有限的 (ulimit -u 命令可查看)。

# 产生僵尸进程的场景

在 Shell 下运行的所有命令，只要该命令不会产生子进程，就一定不会成为永久的僵尸进程，因为 Shell 启动命令的方式是 fork+exec+wait，它会等待它的子进程终止并为子进程收尸。

但是，像 Daemon 类进程，这类进程一般会脱离终端脱离 Shell 进程，而且通常还会产生子进程，那么当子进程退出时，如果程序编码不完善，一直不去给子进程收尸，那么它的子进程将变成永久的僵尸进程。

# 查看僵尸进程

```c
ps -A -o stat,ppid | grep -e ’^[Zz]
ps -e -o ppid,stat | grep Z
ps -ef | grep defunct
ps -ef | grep defunct | grep -v grep | wc -l
```
或者查找状态为Z的进程，Z就是代表zombie process,僵尸进程的意思。

另外使用top命令查看时有一栏为S,如果状态为Z说明它就是僵尸进程。
```c
Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, **0 zombie**
```
> 注：利用命令ps，可以看到有父进程ID为1的进程是孤儿进程；孤儿进程(orphan process)是尚未终止但已停止(相当于前台挂起)的进程，但其父进程已经终止，由init收养；而僵尸进程则是已终止的进程，其父进程不一定终止。

# 僵尸进程和孤儿进程对比
![](attachments/Pasted%20image%2020230705175327.png)
当一个进程正在运行时，他的父进程忽然退出，此时该进程就是一个孤儿进程。作为一个进程，需要找到一个父进程，否则这种进程在退出之后没人回收他的进程描述符，空耗内存。此时该进程会找到一个父进程，如果自己所在的进程组没人收养，那就作为init进程的子进程。
因为 Init进程会为每一个子进程使用wait系统调用，确保不会产生僵尸进程。
注：孤儿进程会被init进程收养，所以什么危害。



# 处理和避免僵尸进程
## 避免僵尸进程
- 思路
现在考虑一个子进程何时成为僵尸进程：
- 子进程先结束，父进程压根没有 wait/waitpid，在父进程结束前，子进程处于僵尸态。
- 子进程先结束，父进程正忙，还没执行到 waitpid，在父进程执行到 waitpid 前，子进程处于僵尸态。

避免僵尸子进程有两种方法：
- 父进程调用 waitpid.
- 父进程早早结束，让 init 收养子进程。

### 捕捉SIGCHLD信号执行wait
子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。就是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，而此时，尽管对它的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。

### 两次fork
- 方法
爷爷第一次 fork 生一个老爸，老爸出生后立刻 fork 生下儿子，这个时候老爸的任务就结束了，可以死掉了 (exit)，这个时候儿子被强大的 init 收养，爷爷爱干啥干啥，从而儿子永远不会成为僵尸进程。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    
    pid = fork();
    if (pid == 0) {
        pid = fork();
        if (pid > 0) {
            //父亲生下儿子直接退出，儿子会被收养
            exit(0);
        }
        sleep(0.5);
        printf("I'm son after second fork. ");
        printf("my parent's pid: %d\n", getppid());
        exit(0);
    }
    //爷爷生下父亲后直接等待为其收尸
    waitpid(pid, NULL, 0);

    //爷爷尽情快活

    exit(0);
}
```

## 处理僵尸进程
当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。
但是我们可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的init进程收养并清理。

## 注意
杀死父进程时要非常小心，如果一个进程的父进程就是 PID 1 ，并且你还杀死了父进程，那么系统将直接重启！

## 原理
如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个 进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动 wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。

